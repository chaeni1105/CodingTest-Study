### [문제 분석]
# 목적 : 봉지의 최소 개수 찾기.
# -> 가장 큰 단위부터 처리하는 방법으로는 해결할 수 없기 때문에,
#    그리디 알고리즘이 아닌 '다이나믹 프로그래밍'을 사용하여 봉지의 최소 개수를 구해야한다.
#    = 이번 문제는, 적은 금액부터 큰 금액까지 확인하며 차례대로 만들 수 있는 최소한의 화폐 개수를 찾으면 된다.

### [문제 풀이]
# 1단계 : 설탕 무게 N을 입력받는다. cnt3과 cnt5를 초기화한다.
# 2단계 : 일단 그리디 알고리즘을 사용하여 total_cnt 값을 구해본다.
#         5로 나누어 떨어지지 않으면 마지막으로 3을 딱 한 번 빼주고 음수가 되면 -1을 출력한다.
# 3단계 : N이 음수가 되버렸으면 -1출력하고, 음수가 아니라 딱맞아 떨어지면 봉지의 최소 개수를 출력한다.


# 1단계
N = int(input())
total_cnt = 0

# 2단계
while True:
    if(N % 5 != 0):
        total_cnt += 1
        N = N - 3
    
    elif(N % 5 == 0):
        total_cnt += N // 5
        print(total_cnt)
        break
        
    if(N < 0):
        print(-1)
        break

# 주의할 점
# 1.조건문을 사용할때는 for문보다 while문이 효과적이다.
# while문은 조건문이 참일 때 한해서 반복적으로 코드가 수행되고,
# for문은 리스트나 튜플 데이터의 모든 원소를 첫 번째 인덱스부터 방문해야 할 때 수행된다.

# 2.N이 음수일때까지 닿으려면, n이 5로 나누어 떨어지지 않을 때 조건식부터 수행해야한다. 순서에 유의할 것.

# 3.반복문 안에서 continue 만나면, 반복문의 처음으로 돌아간다.
# 처음으로 돌아가 버리면 마지막 조건식인 N이 음수일 때까지 못닿으므로, continue를 사용하면 안된다.

# 4.-1이 출력되기 전에 total cnt 출력이 마무리 되어야한다.

# 설탕배달은 3, 5 이렇게 단위가 2개라서 디그리 일 수가 있다. 만약 단위가 이것보다 더 많았다면 다이나믹 프로그래밍으로 풀었어야한다.!
# 다이나믹 프로그래밍 기법은 이후에 다룰 예정이다.